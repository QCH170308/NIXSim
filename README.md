# NIXSim

## Purpose

We propose a fast and accurate RCA (ReRAM Crossbar Array) simulator named 
**NIXSim**, which can be used for early design exploration of ReRAM-based
DNN accelerators.

Our NIXSim is very flexible, which supports various crossbar array settings:

- Crossbar array size
- Balanced & Unbalanced
- Binary & Multi-bit devices
- HRS & LRS
- Wire resistance

Besides, NIXSim can simulate various nonidealities:

- IR drop
- Stuck-at Fault (SAF)
- Variability (programming, local and global)
- Read noise

The entire flow of NIXSim is shown as below:
![image](./Figure/NIXSIM%20Flow.png)

We provide crossbar level simulation, which simulates the behavior of a pair of crossbar arrays (single crossbar array) in balanced (unbalanced) case, and network level simulation, which simulates the whole network behavior in the RCA system.

We provide the SES simulator and a SPICE simulator (SPICE netlist generating script)
as well.

## Dependence

Our NIXSim simulator requires Python (v3.8 in our case) and some Python packages (e.g., Pytorch 1.10). Matlab is required for our SES simulator and SPICE simulation. A SPICE simulator is also needed for SPICE simulation.

## How to run

#### For crossbar level simulation:

- IR drop only simulation:
```
sh sim_test.sh
or
python simulation_test.py --input_quant $abits --weight_quant $wbits --cbsize $cbsize \
       --rw $rw --scn $scn_model
```
Main Options:
```
--input_quant    Input precision (#bits for input values)
--weight_quant   Weight precision (#bits for weight values)
--cbsize        Crossbar array size (a single integer, assuming square array)
--rw            Wire resistance value (Ohm)
--scn           Path to the SCN model file
```

Our trained SCN models can be downloaded here:
https://unistackr0-my.sharepoint.com/:f:/g/personal/quanch_unist_ac_kr/EiPnnhY7Zj1IkNH4MQu9fUYBxXhkYDxc0yMeLJ7Ro-541g?e=QfM9mG

The model files are named as `${cbsize}-${nb}b-spRw${rw}Double.model`. "Double" means
the model is trained for the balanced weight-to-crossbar mapping.
The settings of those models are:  
--Crossbar array size: 32, 64, 128  
--Wire resistance (Ohm): 0.1 (0p1), 1, 2  
--Number of bits (for input & weight): 1, 2, 4, 8  
The currently provided SCN model is trained for IR drop nonideality only, and for balanced mapping only. For other settings, one can train their own SCN model. See "Limitations" below for the limitations of our simulator and pre-trained models.

- Nonideality simulation (considering all nonidealities we mentioned):
```
sh simall_test.sh
or
python nonidealities_test.py --input_quant $abits --weight_quant $wbits --cbsize $cbsize \
       --rw $rw --scn $scn_model --sigma $sig --alpha 1 --sa0 $sa0 --sa1 $sa1 \
       --read_noise $noise --dcrxb true
```
Main Options:
```
--input_quant    Input precision (#bits for input values)
--weight_quant   Weight precision (#bits for weight values)
--cbsize        Crossbar array size (a single integer, assuming square array)
--rw            Wire resistance value (Ohm)
--scn           Path to the SCN model file
--sigma         Std.Dev. value for variability
--alpha         Scale factor for global variability
--sa0 (--sa1)   SA0 (SA1) rate
--read_noise    Read noise scaler
--dcrxb         Balanced (true) or unbalanced (false)
```

#### For network level simulation:
```
sh run_nixsim.sh
or
python main_binary.py --dataset ${Dataset} --model ${model_name} \
       -e ${load_model} --cbsize $cbsize --nb $nb --dcrxb true \
       --sigma $sig --alpha 1 --sa0 $sa0 --sa1 $sa1 --read_noise $noise \
       --scn $scn_model
```
Main Options:
```
--dataset       Dataset (mnist, cifar10)
--model         Network (mlp_mnist_binary, vgg_cifar10_binary)
-e              Load trained model
--cbsize        Crossbar array size
--nb            Weight precision
--dcrxb         Balanced (true) or unbalanced (false)
--sigma         Std.Dev. value for variability
--alpha         Scale factor for global variability
--sa0 (--sa1)   SA0/SA1 rate
--read_noise    Read noise scaler
--scn           Path to the SCN mode file
```

We provide our trained MLP and VGG models here:
https://unistackr0-my.sharepoint.com/:f:/g/personal/quanch_unist_ac_kr/EnNVe4es3jNIlK-An9H02_sBG2zJdmmY04BzvMEtfiS44Q?e=KwgB7r

### SCN model training
For those who want to train a new SCN model, we provide some sample codes for SCN training. Note that our training code is written in Lua torch, so users need to generate training datasets in Lua.

According to the NIXSim flow, the input of SCN model is the weight injected variability and SAF. The size of the weight is the same as crossbar array size. The target of SCN model is the weight effected by IR drop. The target can be generated by SPICE simulator or SES simulator. Note that trained SCN model we provide is trained without considering variability and SAF, i.e. the input of SCN model is the ideal weight. Therefore, we can only guarantee that the provided SCN model predicts well in IR drop only simulation.

After constructing datasets, run ``sh train_l7c32_QNN.sh`` to train the SCN model. The main training code is written in *scn.lua* file. Then run ``sh convert.sh`` to convert the trained SCN model from Lua torch to Pytorch.

## Limitations

NIXSim does not support bit-splitting, which uses multiple low-precision cells to represent high-precision weight. For instance, bit-splitting enable four 2-bit-per-cell devices (i.e., each cell has 4 resistance states) to represent an 8-bit weight parameter.

The pre-trained SCN models we provide are accurate for IR drop only simulation. However, if you inject different amounts of other nonideality (e.g., variability), we cannot guarantee that the provided SCN model predicts well. Therefore, for such cases, users may need to train a new SCN model.
